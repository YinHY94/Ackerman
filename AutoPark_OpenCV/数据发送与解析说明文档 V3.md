# 数据发送与解析说明文档 V3

## 数据格式

两个字节分别表示一个控制模式（`mode`）、一个角度（`angle`），以及一个有符号的距离值（`distance_to_center`）。

1. **第一个字节（byte1）**
   - **前三位：** 表示模式（`mode`）。范围为 `0 ~ 7`，共 3 位。
   - **后五位：** 表示无符号的角度（`angle`）。范围为 `0 ~ 31`，共 5 位。

2. **第二个字节（byte2）**
   - **1 字节：** 表示距离（`distance_to_center`），这是一个有符号整数，范围从 `-128` 到 `127`，表示相对于某一中心点的偏移距离（上方为负，下方为正）。此距离在发送时将被转换为无符号数，但在 STM32 端解析时需要正确处理符号。

## 数据示例

### 发送数据格式：

假设我们需要发送以下数据：

- 模式：`mode_num = 3` （表示模式为3）
- 角度：`angle = 15` （表示角度为15）
- 距离：`distance_to_center = -50` （表示距离中心点偏移50，偏上）

### 第一个字节（byte1）的构成：
- 模式（`mode_num = 3`）的二进制表示为 `011`，占用前三位。
- 角度（`angle = 15`）的二进制表示为 `01111`，占用后五位。

因此，第一个字节是：`byte1 = 011 01111`，即 `byte1 = 0x1F`。

### 第二个字节（byte2）的构成：
- 距离（`distance_to_center = -50`）需要转换为有符号整数范围的无符号表示。`-50` 在有符号的 8 位整数范围中表示为 `0xCE`。

因此，第二个字节是：`byte2 = 0xCE`。

### 发送数据：
```plaintext
byte1 = 0x1F (模式3, 角度15)
byte2 = 0xCE (距离-50)
```

## 数值说明

- **模式（`mode_num`）：** 3 位数据，表示不同的工作模式。有效值范围：`0 ~ 7`。
- **角度（`angle_int`）：** 5 位数据，表示角度的无符号值。有效值范围：`0 ~ 31`。角度值的限制在 `0 ~ 31` 之间，超过会被限制为 `31`。
- **距离（`distance_to_center`）：** 一个有符号的 8 位整数，表示从中心点的偏移距离，单位为像素。有效值范围：`-128 ~ 127`。此值是相对于中心的偏移，上方为负，下方为正。

![image-20250419124007174](./../../../../AppData/Roaming/Typora/typora-user-images/image-20250419124007174.png)

## 通信参数

- 串口波特率：`15200` bps。
- 数据位：`8` 位。
- 停止位：`1` 位。
- 校验位：无校验。

## 流程说明

![image-20250419125219058](./../../../../AppData/Roaming/Typora/typora-user-images/image-20250419125219058.png)

## STM32 解析代码建议

STM32 可以使用以下代码来解析接收到的两个字节数据：

```c
#include "stdio.h"

// 定义接收的字节数据
uint8_t byte1, byte2;

// 解析第一个字节
uint8_t mode_num = byte1 >> 5; // 高3位是模式
uint8_t angle_int = byte1 & 0x1F; // 低5位是角度

// 解析第二个字节
int8_t distance_to_center = (int8_t)byte2; // 第二字节表示带符号的距离

```

### 解析说明：

1. **第一个字节（byte1）**：
   - 使用位移操作将前三位提取为模式 `mode_num`。
   - 使用按位与操作 `0x1F` 提取后五位作为角度 `angle_int`。

2. **第二个字节（byte2）**：
   - 将接收到的无符号字节强制转换为有符号类型 `int8_t`，以获取正确的符号。

## STM32 发送代码示例

```c
void send_0xFF() {
    uint8_t data = 0xFF;  // 要发送的数据 16 进制 0xFF

    // 通过 UART 发送数据
    HAL_UART_Transmit(&huart1, &data, 1, HAL_MAX_DELAY);
}

```